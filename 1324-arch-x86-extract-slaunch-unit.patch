From 7665e099a92dfa3665da8098ac41681928124ae5 Mon Sep 17 00:00:00 2001
From: Sergii Dmytruk <sergii.dmytruk@3mdeb.com>
Date: Sat, 16 Mar 2024 21:25:16 +0200
Subject: [PATCH 1324/1328] arch/x86: extract slaunch unit

To collect its core functionality in one place instead of having some in
intel_txt and other in tpm units.

TXT_EVTYPE_* now live in <asm/slaunch.h> and are called
DLE_EVTYPE_* despite being based on TXT specification.  This way code
for non-Intel won't need to include TXT header.

No functional changes.

Signed-off-by: Sergii Dmytruk <sergii.dmytruk@3mdeb.com>
---
 xen/arch/x86/Makefile                |   1 +
 xen/arch/x86/e820.c                  |   1 +
 xen/arch/x86/include/asm/intel_txt.h |  50 ------
 xen/arch/x86/include/asm/slaunch.h   |  54 ++++++
 xen/arch/x86/intel_txt.c             |  27 +--
 xen/arch/x86/setup.c                 |   1 +
 xen/arch/x86/slaunch.c               | 239 +++++++++++++++++++++++++++
 xen/arch/x86/smpboot.c               |   1 +
 xen/arch/x86/tpm.c                   | 197 +---------------------
 9 files changed, 301 insertions(+), 270 deletions(-)
 create mode 100644 xen/arch/x86/include/asm/slaunch.h
 create mode 100644 xen/arch/x86/slaunch.c

diff --git a/xen/arch/x86/Makefile b/xen/arch/x86/Makefile
index d967aabf29..884929e051 100644
--- a/xen/arch/x86/Makefile
+++ b/xen/arch/x86/Makefile
@@ -60,6 +60,7 @@ obj-y += psr.o
 obj-y += intel_txt.o
 obj-y += setup.o
 obj-y += shutdown.o
+obj-y += slaunch.o
 obj-y += smp.o
 obj-y += smpboot.o
 obj-y += spec_ctrl.o
diff --git a/xen/arch/x86/e820.c b/xen/arch/x86/e820.c
index f836fec189..5b2d960a88 100644
--- a/xen/arch/x86/e820.c
+++ b/xen/arch/x86/e820.c
@@ -12,6 +12,7 @@
 #include <asm/msr.h>
 #include <asm/guest.h>
 #include <asm/intel_txt.h>
+#include <asm/slaunch.h>
 
 /*
  * opt_mem: Limit maximum address of physical RAM.
diff --git a/xen/arch/x86/include/asm/intel_txt.h b/xen/arch/x86/include/asm/intel_txt.h
index 8f9f4d9570..112f670816 100644
--- a/xen/arch/x86/include/asm/intel_txt.h
+++ b/xen/arch/x86/include/asm/intel_txt.h
@@ -80,8 +80,6 @@
 
 #ifndef __ASSEMBLY__
 
-extern bool slaunch_active;
-
 extern char txt_ap_entry[];
 extern uint32_t trampoline_gdt[];
 
@@ -94,8 +92,6 @@ extern uint32_t trampoline_gdt[];
 #define _txt(x) __va(x)
 #endif
 
-#include <xen/slr_table.h>
-
 /*
  * Always use private space as some of registers are either read-only or not
  * present in public space.
@@ -333,39 +329,6 @@ static inline int is_in_pmr(struct txt_os_sinit_data *os_sinit, uint64_t base,
     return 0;
 }
 
-/*
- * This helper function is used to map memory using L2 page tables by aligning
- * mapped regions to 2MB. This way page allocator (which at this point isn't
- * yet initialized) isn't needed for creating new L1 mappings. The function
- * also checks and skips memory already mapped by the prebuilt tables.
- *
- * There is no unmap_l2() because the function is meant to be used for code that
- * accesses TXT registers and TXT heap soon after which Xen rebuilds memory
- * maps, effectively dropping all existing mappings.
- */
-extern int map_l2(unsigned long paddr, unsigned long size);
-
-/* evt_log is a physical address and the caller must map it to virtual, if
- * needed. */
-static inline void find_evt_log(struct slr_table *slrt, void **evt_log,
-                                uint32_t *evt_log_size)
-{
-    struct slr_entry_log_info *log_info;
-
-    log_info = (struct slr_entry_log_info *)
-        slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_LOG_INFO);
-    if ( log_info != NULL )
-    {
-        *evt_log = _p(log_info->addr);
-        *evt_log_size = log_info->size;
-    }
-    else
-    {
-        *evt_log = NULL;
-        *evt_log_size = 0;
-    }
-}
-
 /* Returns physical address. */
 static inline uint32_t txt_find_slrt(void)
 {
@@ -378,17 +341,4 @@ extern void map_txt_mem_regions(void);
 extern void protect_txt_mem_regions(void);
 extern void txt_restore_mtrrs(bool e820_verbose);
 
-#define DRTM_LOC                   2
-#define DRTM_CODE_PCR              17
-#define DRTM_DATA_PCR              18
-
-/*
- * Secure Launch event log entry type. The TXT specification defines the
- * base event value as 0x400 for DRTM values.
- */
-#define TXT_EVTYPE_BASE            0x400
-#define TXT_EVTYPE_SLAUNCH         (TXT_EVTYPE_BASE + 0x102)
-#define TXT_EVTYPE_SLAUNCH_START   (TXT_EVTYPE_BASE + 0x103)
-#define TXT_EVTYPE_SLAUNCH_END     (TXT_EVTYPE_BASE + 0x104)
-
 #endif /* __ASSEMBLY__ */
diff --git a/xen/arch/x86/include/asm/slaunch.h b/xen/arch/x86/include/asm/slaunch.h
new file mode 100644
index 0000000000..03c686061a
--- /dev/null
+++ b/xen/arch/x86/include/asm/slaunch.h
@@ -0,0 +1,54 @@
+#ifndef _ASM_X86_SLAUNCH_H_
+#define _ASM_X86_SLAUNCH_H_
+
+#include <xen/types.h>
+#include <xen/slr_table.h>
+
+#define DRTM_LOC                   2
+#define DRTM_CODE_PCR              17
+#define DRTM_DATA_PCR              18
+
+/*
+ * Secure Launch event log entry types. The TXT specification defines the
+ * base event value as 0x400 for DRTM values.
+ */
+#define TXT_EVTYPE_BASE            0x400
+#define DLE_EVTYPE_SLAUNCH         (TXT_EVTYPE_BASE + 0x102)
+#define DLE_EVTYPE_SLAUNCH_START   (TXT_EVTYPE_BASE + 0x103)
+#define DLE_EVTYPE_SLAUNCH_END     (TXT_EVTYPE_BASE + 0x104)
+
+extern bool slaunch_active;
+
+/* evt_log is a physical address and the caller must map it to virtual, if
+ * needed. */
+static inline void find_evt_log(struct slr_table *slrt, void **evt_log,
+                                uint32_t *evt_log_size)
+{
+    struct slr_entry_log_info *log_info =
+        (void *)slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_LOG_INFO);
+
+    if ( log_info != NULL )
+    {
+        *evt_log = _p(log_info->addr);
+        *evt_log_size = log_info->size;
+    }
+    else
+    {
+        *evt_log = NULL;
+        *evt_log_size = 0;
+    }
+}
+
+/*
+ * This helper function is used to map memory using L2 page tables by aligning
+ * mapped regions to 2MB. This way page allocator (which at this point isn't
+ * yet initialized) isn't needed for creating new L1 mappings. The function
+ * also checks and skips memory already mapped by the prebuilt tables.
+ *
+ * There is no unmap_l2() because the function is meant to be used for code that
+ * accesses TXT registers and TXT heap soon after which Xen rebuilds memory
+ * maps, effectively dropping all existing mappings.
+ */
+extern int map_l2(unsigned long paddr, unsigned long size);
+
+#endif /* _ASM_X86_SLAUNCH_H_ */
diff --git a/xen/arch/x86/intel_txt.c b/xen/arch/x86/intel_txt.c
index f07a1044ee..36fda89cf2 100644
--- a/xen/arch/x86/intel_txt.c
+++ b/xen/arch/x86/intel_txt.c
@@ -5,6 +5,7 @@
 #include <xen/string.h>
 #include <asm/page.h>
 #include <asm/intel_txt.h>
+#include <asm/slaunch.h>
 #include <asm/tpm.h>
 #include <xen/init.h>
 #include <xen/mm.h>
@@ -12,32 +13,6 @@
 
 static uint64_t __initdata txt_heap_base, txt_heap_size;
 
-bool __initdata slaunch_active;
-
-static void __maybe_unused compile_time_checks(void)
-{
-    BUILD_BUG_ON(sizeof(slaunch_active) != 1);
-}
-
-int __init map_l2(unsigned long paddr, unsigned long size)
-{
-    unsigned long aligned_paddr = paddr & ~((1ULL << L2_PAGETABLE_SHIFT) - 1);
-    unsigned long pages = ((paddr + size) - aligned_paddr);
-    pages = ROUNDUP(pages, 1ULL << L2_PAGETABLE_SHIFT) >> PAGE_SHIFT;
-
-    if ( (aligned_paddr + pages * PAGE_SIZE) <= PREBUILT_MAP_LIMIT )
-        return 0;
-
-    if ( aligned_paddr < PREBUILT_MAP_LIMIT ) {
-        pages -= (PREBUILT_MAP_LIMIT - aligned_paddr) >> PAGE_SHIFT;
-        aligned_paddr = PREBUILT_MAP_LIMIT;
-    }
-
-    return map_pages_to_xen((unsigned long)__va(aligned_paddr),
-                            maddr_to_mfn(aligned_paddr),
-                            pages, PAGE_HYPERVISOR);
-}
-
 void __init map_txt_mem_regions(void)
 {
     void *evt_log_addr;
diff --git a/xen/arch/x86/setup.c b/xen/arch/x86/setup.c
index 519e3311f5..75e5dbb725 100644
--- a/xen/arch/x86/setup.c
+++ b/xen/arch/x86/setup.c
@@ -56,6 +56,7 @@
 #include <asm/microcode.h>
 #include <asm/pv/domain.h>
 #include <asm/intel_txt.h>
+#include <asm/slaunch.h>
 #include <asm/tpm.h>
 
 /* opt_nosmp: If true, secondary processors are ignored. */
diff --git a/xen/arch/x86/slaunch.c b/xen/arch/x86/slaunch.c
new file mode 100644
index 0000000000..07500ee8db
--- /dev/null
+++ b/xen/arch/x86/slaunch.c
@@ -0,0 +1,239 @@
+#include <xen/types.h>
+#include <asm/intel_txt.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/slaunch.h>
+#include <asm/tpm.h>
+#include <xen/init.h>
+#include <xen/mm.h>
+#include <xen/multiboot.h>
+
+bool __initdata slaunch_active;
+
+static void __maybe_unused compile_time_checks(void)
+{
+    BUILD_BUG_ON(sizeof(slaunch_active) != 1);
+}
+
+int __init map_l2(unsigned long paddr, unsigned long size)
+{
+    unsigned long aligned_paddr = paddr & ~((1ULL << L2_PAGETABLE_SHIFT) - 1);
+    unsigned long pages = ((paddr + size) - aligned_paddr);
+    pages = ROUNDUP(pages, 1ULL << L2_PAGETABLE_SHIFT) >> PAGE_SHIFT;
+
+    if ( (aligned_paddr + pages * PAGE_SIZE) <= PREBUILT_MAP_LIMIT )
+        return 0;
+
+    if ( aligned_paddr < PREBUILT_MAP_LIMIT )
+    {
+        pages -= (PREBUILT_MAP_LIMIT - aligned_paddr) >> PAGE_SHIFT;
+        aligned_paddr = PREBUILT_MAP_LIMIT;
+    }
+
+    return map_pages_to_xen((unsigned long)__va(aligned_paddr),
+                            maddr_to_mfn(aligned_paddr),
+                            pages, PAGE_HYPERVISOR);
+}
+
+static struct slr_table *slr_get_table(void)
+{
+    uint32_t slrt_pa = txt_find_slrt();
+    struct slr_table *slrt = __va(slrt_pa);
+
+    map_l2(slrt_pa, PAGE_SIZE);
+
+    if ( slrt->magic != SLR_TABLE_MAGIC )
+        panic("SLRT has invalid magic value: %#08x!\n", slrt->magic);
+    /* XXX: are newer revisions allowed? */
+    if ( slrt->revision != SLR_TABLE_REVISION )
+        panic("SLRT is of unsupported revision: %#04x!\n", slrt->revision);
+    if ( slrt->architecture != SLR_INTEL_TXT )
+        panic("SLRT is for unexpected architecture: %#04x!\n",
+              slrt->architecture);
+    if ( slrt->size > slrt->max_size )
+        panic("SLRT is larger than its max size: %#08x > %#08x!\n",
+              slrt->size, slrt->max_size);
+
+    if ( slrt->size > PAGE_SIZE )
+        map_l2(slrt_pa, slrt->size);
+
+    return slrt;
+}
+
+void tpm_measure_slrt(void)
+{
+    struct slr_table *slrt = slr_get_table();
+
+    if ( slrt->revision == 1 )
+    {
+        /* In revision one of the SLRT, only Intel info table is measured. */
+        struct slr_entry_intel_info *intel_info =
+            (void *)slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_INTEL_INFO);
+        if ( intel_info == NULL )
+            panic("SLRT is missing Intel-specific information!\n");
+
+        tpm_hash_extend(DRTM_LOC, DRTM_DATA_PCR, (uint8_t *)intel_info,
+                        sizeof(*intel_info), DLE_EVTYPE_SLAUNCH, NULL, 0);
+    }
+    else
+    {
+        /*
+         * slr_get_table() checks that the revision is valid, so we must not
+         * get here unless the code is wrong.
+         */
+        panic("Unhandled SLRT revision: %d!\n", slrt->revision);
+    }
+}
+
+static struct slr_entry_policy *slr_get_policy(struct slr_table *slrt)
+{
+    struct slr_entry_policy *policy;
+
+    policy = (struct slr_entry_policy *)
+        slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_DRTM_POLICY);
+    if (policy == NULL)
+        panic("SLRT is missing DRTM policy!\n");
+
+    /* XXX: are newer revisions allowed? */
+    if ( policy->revision != SLR_POLICY_REVISION )
+        panic("DRTM policy in SLRT is of unsupported revision: %#04x!\n",
+              slrt->revision);
+
+    return policy;
+}
+
+static void check_drtm_policy(struct slr_table *slrt,
+                              struct slr_entry_policy *policy,
+                              struct slr_policy_entry *policy_entry,
+                              const multiboot_info_t *mbi)
+{
+    uint32_t i;
+    module_t *mods;
+    uint32_t num_mod_entries;
+
+    if ( policy->nr_entries < 2 )
+        panic("DRTM policy in SLRT contains less than 2 entries (%d)!\n",
+              policy->nr_entries);
+
+    /* MBI policy entry must be the first one, so that measuring order matches
+     * policy order. */
+    if ( policy_entry[0].entity_type != SLR_ET_MULTIBOOT2_INFO )
+        panic("First entry of DRTM policy in SLRT is not MBI: %#04x!\n",
+              policy_entry[0].entity_type);
+    if ( policy_entry[0].pcr != DRTM_DATA_PCR )
+        panic("MBI was measured to %d instead of %d PCR!\n", DRTM_DATA_PCR,
+              policy_entry[0].pcr);
+
+    /* SLRT policy entry must be the second one. */
+    if ( policy_entry[1].entity_type != SLR_ET_SLRT )
+        panic("Second entry of DRTM policy in SLRT is not SLRT: %#04x!\n",
+              policy_entry[1].entity_type);
+    if ( policy_entry[1].pcr != DRTM_DATA_PCR )
+        panic("SLRT was measured to %d instead of %d PCR!\n", DRTM_DATA_PCR,
+              policy_entry[1].pcr);
+    if ( policy_entry[1].entity != (uint64_t)__pa(slrt) )
+        panic("SLRT address (%#08lx) differes from its DRTM entry (%#08lx)\n",
+              __pa(slrt), policy_entry[1].entity);
+
+    mods = __va(mbi->mods_addr);
+    for ( i = 0; i < mbi->mods_count; i++ )
+    {
+        uint16_t j;
+        uint64_t start = mods[i].mod_start;
+        uint64_t size = mods[i].mod_end - mods[i].mod_start;
+
+        for ( j = 0; j < policy->nr_entries; j++ )
+        {
+            if ( policy_entry[j].entity_type != SLR_ET_MULTIBOOT2_MODULE )
+                continue;
+
+            if ( policy_entry[j].entity == start &&
+                 policy_entry[j].size == size )
+                break;
+        }
+
+        if ( j >= policy->nr_entries )
+        {
+            panic("Couldn't find Multiboot module \"%s\" (at %d) in DRTM of Secure Launch\n",
+                  (const char *)__va(mods[i].string), i);
+        }
+    }
+
+    num_mod_entries = 0;
+    for ( i = 0; i < policy->nr_entries; i++ )
+    {
+        if ( policy_entry[i].entity_type == SLR_ET_MULTIBOOT2_MODULE )
+            num_mod_entries++;
+    }
+
+    if ( mbi->mods_count != num_mod_entries )
+    {
+        panic("Unexpected number of Multiboot modules: %d instead of %d\n",
+              (int)mbi->mods_count, (int)num_mod_entries);
+    }
+}
+
+void tpm_process_drtm_policy(const multiboot_info_t *mbi)
+{
+    struct slr_table *slrt;
+    struct slr_entry_policy *policy;
+    struct slr_policy_entry *policy_entry;
+    uint16_t i;
+
+    slrt = slr_get_table();
+
+    policy = slr_get_policy(slrt);
+    policy_entry = (struct slr_policy_entry *)
+        ((uint8_t *)policy + sizeof(*policy));
+
+    check_drtm_policy(slrt, policy, policy_entry, mbi);
+    /* MBI was measured in tpm_extend_mbi(). */
+    policy_entry[0].flags |= SLR_POLICY_FLAG_MEASURED;
+    /* SLRT was measured in tpm_measure_slrt(). */
+    policy_entry[1].flags |= SLR_POLICY_FLAG_MEASURED;
+
+    for ( i = 2; i < policy->nr_entries; i++ )
+    {
+        uint64_t start = policy_entry[i].entity;
+        uint64_t size = policy_entry[i].size;
+
+        /* No already measured entries are expected here. */
+        if ( policy_entry[i].flags & SLR_POLICY_FLAG_MEASURED )
+            panic("DRTM entry at %d was measured out of order!\n", i);
+
+        switch ( policy_entry[i].entity_type )
+        {
+        case SLR_ET_MULTIBOOT2_INFO:
+            panic("Duplicated MBI entry in DRTM of Secure Launch at %d\n", i);
+        case SLR_ET_SLRT:
+            panic("Duplicated SLRT entry in DRTM of Secure Launch at %d\n", i);
+
+        case SLR_ET_UNSPECIFIED:
+        case SLR_ET_BOOT_PARAMS:
+        case SLR_ET_SETUP_DATA:
+        case SLR_ET_CMDLINE:
+        case SLR_ET_UEFI_MEMMAP:
+        case SLR_ET_RAMDISK:
+        case SLR_ET_MULTIBOOT2_MODULE:
+        case SLR_ET_TXT_OS2MLE:
+            /* Measure this entry below. */
+            break;
+
+        case SLR_ET_UNUSED:
+            /* Skip this entry. */
+            continue;
+        }
+
+        if ( policy_entry[i].flags & SLR_POLICY_IMPLICIT_SIZE )
+            panic("Unexpected implicitly-sized DRTM entry of Secure Launch at %d\n",
+                  i);
+
+        map_l2(start, size);
+        tpm_hash_extend(DRTM_LOC, policy_entry[i].pcr, __va(start), size,
+                        DLE_EVTYPE_SLAUNCH, (uint8_t *)policy_entry[i].evt_info,
+                        strnlen(policy_entry[i].evt_info,
+                                TPM_EVENT_INFO_LENGTH));
+
+        policy_entry[i].flags |= SLR_POLICY_FLAG_MEASURED;
+    }
+}
diff --git a/xen/arch/x86/smpboot.c b/xen/arch/x86/smpboot.c
index c732e5ace7..ecbc645ae1 100644
--- a/xen/arch/x86/smpboot.c
+++ b/xen/arch/x86/smpboot.c
@@ -40,6 +40,7 @@
 #include <asm/flushtlb.h>
 #include <asm/guest.h>
 #include <asm/intel_txt.h>
+#include <asm/slaunch.h>
 #include <asm/microcode.h>
 #include <asm/msr.h>
 #include <asm/mtrr.h>
diff --git a/xen/arch/x86/tpm.c b/xen/arch/x86/tpm.c
index 58cddf7c8c..b075dafaf2 100644
--- a/xen/arch/x86/tpm.c
+++ b/xen/arch/x86/tpm.c
@@ -29,6 +29,7 @@ asm (
 
 #include "boot/defs.h"
 #include "include/asm/intel_txt.h"
+#include "include/asm/slaunch.h"
 #include "include/asm/tpm.h"
 #ifdef __va
 #error "__va defined in non-paged mode!"
@@ -66,6 +67,7 @@ void *memcpy(void *dest, const void *src, size_t n)
 #include <xen/pfn.h>
 #include <xen/types.h>
 #include <asm/intel_txt.h>
+#include <asm/slaunch.h>
 #include <asm/tpm.h>
 
 #endif  /* __EARLY_TPM__ */
@@ -978,199 +980,6 @@ void __stdcall tpm_extend_mbi(uint32_t *mbi)
 {
     /* MBI starts with uint32_t total_size. */
     tpm_hash_extend(DRTM_LOC, DRTM_DATA_PCR, (uint8_t *)mbi, *mbi,
-                    TXT_EVTYPE_SLAUNCH, NULL, 0);
-}
-#else
-static struct slr_table *slr_get_table(void)
-{
-    uint32_t slrt_pa = txt_find_slrt();
-    struct slr_table *slrt = __va(slrt_pa);
-
-    map_l2(slrt_pa, PAGE_SIZE);
-
-    if ( slrt->magic != SLR_TABLE_MAGIC )
-        panic("SLRT has invalid magic value: %#08x!\n", slrt->magic);
-    /* XXX: are newer revisions allowed? */
-    if ( slrt->revision != SLR_TABLE_REVISION )
-        panic("SLRT is of unsupported revision: %#04x!\n", slrt->revision);
-    if ( slrt->architecture != SLR_INTEL_TXT )
-        panic("SLRT is for unexpected architecture: %#04x!\n",
-              slrt->architecture);
-    if ( slrt->size > slrt->max_size )
-        panic("SLRT is larger than its max size: %#08x > %#08x!\n",
-              slrt->size, slrt->max_size);
-
-    if ( slrt->size > PAGE_SIZE )
-        map_l2(slrt_pa, slrt->size);
-
-    return slrt;
-}
-
-void tpm_measure_slrt(void)
-{
-    struct slr_table *slrt = slr_get_table();
-
-    if ( slrt->revision == 1 ) {
-        /* In revision one of the SLRT, only Intel info table is measured. */
-        struct slr_entry_intel_info *intel_info =
-            (void *)slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_INTEL_INFO);
-        if ( intel_info == NULL )
-            panic("SLRT is missing Intel-specific information!\n");
-
-        tpm_hash_extend(DRTM_LOC, DRTM_DATA_PCR, (uint8_t *)intel_info,
-                        sizeof(*intel_info), TXT_EVTYPE_SLAUNCH, NULL, 0);
-    } else {
-        /*
-         * slr_get_table() checks that the revision is valid, so we must not
-         * get here unless the code is wrong.
-         */
-        panic("Unhandled SLRT revision: %d!\n", slrt->revision);
-    }
-}
-
-static struct slr_entry_policy *slr_get_policy(struct slr_table *slrt)
-{
-    struct slr_entry_policy *policy;
-
-    policy = (struct slr_entry_policy *)
-        slr_next_entry_by_tag(slrt, NULL, SLR_ENTRY_DRTM_POLICY);
-    if (policy == NULL)
-        panic("SLRT is missing DRTM policy!\n");
-
-    /* XXX: are newer revisions allowed? */
-    if ( policy->revision != SLR_POLICY_REVISION )
-        panic("DRTM policy in SLRT is of unsupported revision: %#04x!\n",
-              slrt->revision);
-
-    return policy;
-}
-
-static void check_drtm_policy(struct slr_table *slrt,
-                              struct slr_entry_policy *policy,
-                              struct slr_policy_entry *policy_entry,
-                              const multiboot_info_t *mbi)
-{
-    uint32_t i;
-    module_t *mods;
-    uint32_t num_mod_entries;
-
-    if ( policy->nr_entries < 2 )
-        panic("DRTM policy in SLRT contains less than 2 entries (%d)!\n",
-              policy->nr_entries);
-
-    /* MBI policy entry must be the first one, so that measuring order matches
-     * policy order. */
-    if ( policy_entry[0].entity_type != SLR_ET_MULTIBOOT2_INFO )
-        panic("First entry of DRTM policy in SLRT is not MBI: %#04x!\n",
-              policy_entry[0].entity_type);
-    if ( policy_entry[0].pcr != DRTM_DATA_PCR )
-        panic("MBI was measured to %d instead of %d PCR!\n", DRTM_DATA_PCR,
-              policy_entry[0].pcr);
-
-    /* SLRT policy entry must be the second one. */
-    if ( policy_entry[1].entity_type != SLR_ET_SLRT )
-        panic("Second entry of DRTM policy in SLRT is not SLRT: %#04x!\n",
-              policy_entry[1].entity_type);
-    if ( policy_entry[1].pcr != DRTM_DATA_PCR )
-        panic("SLRT was measured to %d instead of %d PCR!\n", DRTM_DATA_PCR,
-              policy_entry[1].pcr);
-    if ( policy_entry[1].entity != (uint64_t)__pa(slrt) )
-        panic("SLRT address (%#08lx) differes from its DRTM entry (%#08lx)\n",
-              __pa(slrt), policy_entry[1].entity);
-
-    mods = __va(mbi->mods_addr);
-    for ( i = 0; i < mbi->mods_count; i++ ) {
-        uint16_t j;
-        uint64_t start = mods[i].mod_start;
-        uint64_t size = mods[i].mod_end - mods[i].mod_start;
-
-        for ( j = 0; j < policy->nr_entries; j++ ) {
-            if ( policy_entry[j].entity_type != SLR_ET_MULTIBOOT2_MODULE )
-                continue;
-
-            if ( policy_entry[j].entity == start &&
-                 policy_entry[j].size == size )
-                break;
-        }
-
-        if ( j >= policy->nr_entries ) {
-            panic("Couldn't find Multiboot module \"%s\" (at %d) in DRTM of Secure Launch\n",
-                  (const char *)__va(mods[i].string), i);
-        }
-    }
-
-    num_mod_entries = 0;
-    for ( i = 0; i < policy->nr_entries; i++ ) {
-        if ( policy_entry[i].entity_type == SLR_ET_MULTIBOOT2_MODULE )
-            num_mod_entries++;
-    }
-
-    if ( mbi->mods_count != num_mod_entries ) {
-        panic("Unexpected number of Multiboot modules: %d instead of %d\n",
-              (int)mbi->mods_count, (int)num_mod_entries);
-    }
-}
-
-void tpm_process_drtm_policy(const multiboot_info_t *mbi)
-{
-    struct slr_table *slrt;
-    struct slr_entry_policy *policy;
-    struct slr_policy_entry *policy_entry;
-    uint16_t i;
-
-    slrt = slr_get_table();
-
-    policy = slr_get_policy(slrt);
-    policy_entry = (struct slr_policy_entry *)
-        ((uint8_t *)policy + sizeof(*policy));
-
-    check_drtm_policy(slrt, policy, policy_entry, mbi);
-    /* MBI was measured in tpm_extend_mbi(). */
-    policy_entry[0].flags |= SLR_POLICY_FLAG_MEASURED;
-    /* SLRT was measured in tpm_measure_slrt(). */
-    policy_entry[1].flags |= SLR_POLICY_FLAG_MEASURED;
-
-    for ( i = 2; i < policy->nr_entries; i++ ) {
-        uint64_t start = policy_entry[i].entity;
-        uint64_t size = policy_entry[i].size;
-
-        /* No already measured entries are expected here. */
-        if ( policy_entry[i].flags & SLR_POLICY_FLAG_MEASURED )
-            panic("DRTM entry at %d was measured out of order!\n", i);
-
-        switch ( policy_entry[i].entity_type ) {
-        case SLR_ET_MULTIBOOT2_INFO:
-            panic("Duplicated MBI entry in DRTM of Secure Launch at %d\n", i);
-        case SLR_ET_SLRT:
-            panic("Duplicated SLRT entry in DRTM of Secure Launch at %d\n", i);
-
-        case SLR_ET_UNSPECIFIED:
-        case SLR_ET_BOOT_PARAMS:
-        case SLR_ET_SETUP_DATA:
-        case SLR_ET_CMDLINE:
-        case SLR_ET_UEFI_MEMMAP:
-        case SLR_ET_RAMDISK:
-        case SLR_ET_MULTIBOOT2_MODULE:
-        case SLR_ET_TXT_OS2MLE:
-            /* Measure this entry below. */
-            break;
-
-        case SLR_ET_UNUSED:
-            /* Skip this entry. */
-            continue;
-        }
-
-        if ( policy_entry[i].flags & SLR_POLICY_IMPLICIT_SIZE )
-            panic("Unexpected implicitly-sized DRTM entry of Secure Launch at %d\n",
-                  i);
-
-        map_l2(start, size);
-        tpm_hash_extend(DRTM_LOC, policy_entry[i].pcr, __va(start), size,
-                        TXT_EVTYPE_SLAUNCH, (uint8_t *)policy_entry[i].evt_info,
-                        strnlen(policy_entry[i].evt_info,
-                                TPM_EVENT_INFO_LENGTH));
-
-        policy_entry[i].flags |= SLR_POLICY_FLAG_MEASURED;
-    }
+                    DLE_EVTYPE_SLAUNCH, NULL, 0);
 }
 #endif
-- 
2.46.0


--- a/xen/arch/x86/io_apic.c
+++ b/xen/arch/x86/io_apic.c
@@ -298,8 +298,15 @@ static void __io_apic_eoi(unsigned int apic, unsigned int vector, unsigned int p
     /* Prefer the use of the EOI register if available */
     if ( ioapic_has_eoi_reg(apic) )
     {
-        /* If vector is unknown, read it from the IO-APIC */
-        if ( vector == IRQ_VECTOR_UNASSIGNED )
+        /* If vector is unknown, read it from the IO-APIC. Also,
+         * with interrupt remapping, the field the IO-APIC thinks
+         * is the "vector" might be something completely different.
+         * With an AMD IOMMU it's the low bits of the IRTE index
+         * into the IOMMU's table, for example. So using the actual
+         * delivery vector which is stored in the IRTE would be wrong;
+         * we need to use the actual bits the IO-APIC sees in the RTE.
+         */
+        if ( iommu_intremap || vector == IRQ_VECTOR_UNASSIGNED )
             vector = __ioapic_read_entry(apic, pin, true).vector;
 
         *(IO_APIC_BASE(apic)+16) = vector;



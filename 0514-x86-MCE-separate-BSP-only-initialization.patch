From 2268aacc4324f6010058c2e3bbb214a280dc8078 Mon Sep 17 00:00:00 2001
From: Jan Beulich <jbeulich@suse.com>
Date: Mon, 22 Jan 2024 13:40:32 +0100
Subject: [PATCH 514/542] x86/MCE: separate BSP-only initialization

Several function pointers are registered over and over again, when
setting them once on the BSP suffices. Arrange for this in the vendor
init functions and mark involved registration functions __init.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
(cherry picked from commit 9f58616ddb1cc1870399de2202fafc7bf0d61694)
---
 xen/arch/x86/cpu/mcheck/mcaction.c  |  2 +-
 xen/arch/x86/cpu/mcheck/mce.c       | 15 ++++++---------
 xen/arch/x86/cpu/mcheck/mce.h       |  2 +-
 xen/arch/x86/cpu/mcheck/mce_amd.c   | 20 +++++++++++++-------
 xen/arch/x86/cpu/mcheck/mce_intel.c | 10 +++++++---
 5 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/xen/arch/x86/cpu/mcheck/mcaction.c b/xen/arch/x86/cpu/mcheck/mcaction.c
index f4f265c1bc..695fb61d7d 100644
--- a/xen/arch/x86/cpu/mcheck/mcaction.c
+++ b/xen/arch/x86/cpu/mcheck/mcaction.c
@@ -29,7 +29,7 @@ mci_action_add_pageoffline(int bank, struct mc_info *mi,
 
 mce_check_addr_t mc_check_addr = NULL;
 
-void mce_register_addrcheck(mce_check_addr_t cbfunc)
+void __init mce_register_addrcheck(mce_check_addr_t cbfunc)
 {
     mc_check_addr = cbfunc;
 }
diff --git a/xen/arch/x86/cpu/mcheck/mce.c b/xen/arch/x86/cpu/mcheck/mce.c
index f68e31b643..0b164e2027 100644
--- a/xen/arch/x86/cpu/mcheck/mce.c
+++ b/xen/arch/x86/cpu/mcheck/mce.c
@@ -84,7 +84,7 @@ static void cf_check unexpected_machine_check(const struct cpu_user_regs *regs)
 
 static x86_mce_vector_t _machine_check_vector = unexpected_machine_check;
 
-void x86_mce_vector_register(x86_mce_vector_t hdlr)
+void __init x86_mce_vector_register(x86_mce_vector_t hdlr)
 {
     _machine_check_vector = hdlr;
 }
@@ -107,7 +107,7 @@ void do_machine_check(const struct cpu_user_regs *regs)
  */
 static x86_mce_callback_t mc_callback_bank_extended = NULL;
 
-void x86_mce_callback_register(x86_mce_callback_t cbfunc)
+void __init x86_mce_callback_register(x86_mce_callback_t cbfunc)
 {
     mc_callback_bank_extended = cbfunc;
 }
@@ -118,7 +118,7 @@ void x86_mce_callback_register(x86_mce_callback_t cbfunc)
  */
 static mce_recoverable_t mc_recoverable_scan = NULL;
 
-void mce_recoverable_register(mce_recoverable_t cbfunc)
+void __init mce_recoverable_register(mce_recoverable_t cbfunc)
 {
     mc_recoverable_scan = cbfunc;
 }
@@ -182,7 +182,7 @@ static void mcabank_clear(int banknum)
  */
 static mce_need_clearbank_t mc_need_clearbank_scan = NULL;
 
-void mce_need_clearbank_register(mce_need_clearbank_t cbfunc)
+void __init mce_need_clearbank_register(mce_need_clearbank_t cbfunc)
 {
     mc_need_clearbank_scan = cbfunc;
 }
@@ -799,7 +799,7 @@ void mcheck_init(struct cpuinfo_x86 *c, bool bsp)
     {
     case X86_VENDOR_AMD:
     case X86_VENDOR_HYGON:
-        inited = amd_mcheck_init(c);
+        inited = amd_mcheck_init(c, bsp);
         break;
 
     case X86_VENDOR_INTEL:
@@ -1913,11 +1913,8 @@ static void cf_check mce_softirq(void)
  * will help to collect and log those MCE errors.
  * Round2: Do all MCE processing logic as normal.
  */
-void mce_handler_init(void)
+void __init mce_handler_init(void)
 {
-    if ( smp_processor_id() != 0 )
-        return;
-
     /* callback register, do we really need so many callback? */
     /* mce handler data initialization */
     spin_lock_init(&mce_logout_lock);
diff --git a/xen/arch/x86/cpu/mcheck/mce.h b/xen/arch/x86/cpu/mcheck/mce.h
index bea08bdc74..10ed059f7c 100644
--- a/xen/arch/x86/cpu/mcheck/mce.h
+++ b/xen/arch/x86/cpu/mcheck/mce.h
@@ -44,7 +44,7 @@ extern uint8_t cmci_apic_vector;
 extern bool lmce_support;
 
 /* Init functions */
-enum mcheck_type amd_mcheck_init(struct cpuinfo_x86 *c);
+enum mcheck_type amd_mcheck_init(const struct cpuinfo_x86 *c, bool bsp);
 enum mcheck_type intel_mcheck_init(struct cpuinfo_x86 *c, bool bsp);
 
 void amd_nonfatal_mcheck_init(struct cpuinfo_x86 *c);
diff --git a/xen/arch/x86/cpu/mcheck/mce_amd.c b/xen/arch/x86/cpu/mcheck/mce_amd.c
index d7ae8919df..cf80e1a275 100644
--- a/xen/arch/x86/cpu/mcheck/mce_amd.c
+++ b/xen/arch/x86/cpu/mcheck/mce_amd.c
@@ -284,7 +284,7 @@ int vmce_amd_rdmsr(const struct vcpu *v, uint32_t msr, uint64_t *val)
 }
 
 enum mcheck_type
-amd_mcheck_init(struct cpuinfo_x86 *ci)
+amd_mcheck_init(const struct cpuinfo_x86 *ci, bool bsp)
 {
     uint32_t i;
     enum mcequirk_amd_flags quirkflag = 0;
@@ -294,9 +294,12 @@ amd_mcheck_init(struct cpuinfo_x86 *ci)
 
     /* Assume that machine check support is available.
      * The minimum provided support is at least the K8. */
-    mce_handler_init();
-    x86_mce_vector_register(mcheck_cmn_handler);
-    mce_need_clearbank_register(amd_need_clearbank_scan);
+    if ( bsp )
+    {
+        mce_handler_init();
+        x86_mce_vector_register(mcheck_cmn_handler);
+        mce_need_clearbank_register(amd_need_clearbank_scan);
+    }
 
     for ( i = 0; i < this_cpu(nr_mce_banks); i++ )
     {
@@ -336,9 +339,12 @@ amd_mcheck_init(struct cpuinfo_x86 *ci)
             ppin_msr = MSR_AMD_PPIN;
     }
 
-    x86_mce_callback_register(amd_f10_handler);
-    mce_recoverable_register(mc_amd_recoverable_scan);
-    mce_register_addrcheck(mc_amd_addrcheck);
+    if ( bsp )
+    {
+        x86_mce_callback_register(amd_f10_handler);
+        mce_recoverable_register(mc_amd_recoverable_scan);
+        mce_register_addrcheck(mc_amd_addrcheck);
+    }
 
     return ci->x86_vendor == X86_VENDOR_HYGON ?
             mcheck_hygon : mcheck_amd_famXX;
diff --git a/xen/arch/x86/cpu/mcheck/mce_intel.c b/xen/arch/x86/cpu/mcheck/mce_intel.c
index ce7678f242..837a8c6d0c 100644
--- a/xen/arch/x86/cpu/mcheck/mce_intel.c
+++ b/xen/arch/x86/cpu/mcheck/mce_intel.c
@@ -814,7 +814,7 @@ static void intel_mce_post_reset(void)
     return;
 }
 
-static void intel_init_mce(void)
+static void intel_init_mce(bool bsp)
 {
     uint64_t msr_content;
     int i;
@@ -840,6 +840,9 @@ static void intel_init_mce(void)
     if ( firstbank ) /* if cmci enabled, firstbank = 0 */
         wrmsrl(MSR_IA32_MC0_STATUS, 0x0ULL);
 
+    if ( !bsp )
+        return;
+
     x86_mce_vector_register(mcheck_cmn_handler);
     mce_recoverable_register(intel_recoverable_scan);
     mce_need_clearbank_register(intel_need_clearbank_scan);
@@ -979,9 +982,10 @@ enum mcheck_type intel_mcheck_init(struct cpuinfo_x86 *c, bool bsp)
 
     intel_init_mca(c);
 
-    mce_handler_init();
+    if ( bsp )
+        mce_handler_init();
 
-    intel_init_mce();
+    intel_init_mce(bsp);
 
     intel_init_cmci(c);
 
-- 
2.44.0

